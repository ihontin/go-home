package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

//Пример 1
//В этом примере мы создаем канал limit с емкостью 3, который будет использоваться для ограничения количества активных горутин.
//Затем мы запускаем 5 горутин, каждая из которых выполняет задачу и отправляет свой идентификатор в канал.
//Горутины, пытающиеся отправить данные в канал, будут блокироваться, если канал заполнен до своей емкости.
//Таким образом, только первые 3 горутины будут активными, а остальные будут ожидать освобождения места в канале.
//func worker(id int, limit chan struct{}) {
//	// Задержка для имитации выполнения задачи
//	time.Sleep(time.Second)
//	fmt.Printf("Горутина %d завершила выполнение задачи\n", id)
//	<-limit // Освобождение места в канале
//}
//func main() {
//	numWorkers := 5
//	limit := make(chan struct{}, 3)
//
//	for i := 1; i <= numWorkers; i++ {
//		limit <- struct{}{} // Занятие места в канале
//		go worker(i, limit)
//	}
//
//	time.Sleep(2 * time.Second) // Ожидание завершения работы горутин
//	close(limit)
//}

//Пример 2
//В этом примере мы используем каналы для ограничения количества параллельных HTTP-запросов.
//Мы создаем канал semaphore с емкостью 3, который будет использоваться для ограничения количества активных горутин.
//Затем мы запускаем 10 горутин, каждая из которых выполняет HTTP-запрос и отправляет результат в канал results.
//Горутины, пытающиеся отправить данные в канал, будут блокироваться, если канал заполнен до своей емкости.
//Таким образом, только первые 3 горутины будут активными, а остальные будут ожидать освобождения места в канале.

func worker(id int, semaphore chan struct{}, results chan<- string) {
	// Выполнение HTTP-запроса
	resp, err := http.Get("https://example.com")
	if err != nil {
		results <- fmt.Sprintf("Горутина %d: ошибка выполнения запроса", id)
		return
	}
	defer resp.Body.Close()

	// Чтение ответа
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		results <- fmt.Sprintf("Горутина %d: ошибка чтения ответа", id)
		return
	}

	results <- fmt.Sprintf("Горутина %d: %s", id, body)
	<-semaphore // Освобождение места в канале
}

func main() {
	numWorkers := 10
	semaphore := make(chan struct{}, 3)
	results := make(chan string, numWorkers)

	for i := 1; i <= numWorkers; i++ {
		semaphore <- struct{}{} // Занятие места в канале
		go worker(i, semaphore, results)
	}

	for i := 1; i <= numWorkers; i++ {
		result := <-results
		fmt.Println(result)
	}

	close(semaphore)
	close(results)
}

//Пример 3
//Пример использования ограничения количества горутин каналами:
//В данном примере мы создаем 3 горутины-работника, которые выполняют задачи из канала jobs и отправляют результаты в канал results.
//Канал jobs имеет емкость numJobs, что ограничивает количество активных горутин до numJobs.
//Когда все задачи выполнены, мы получаем результаты из канала results.
//В этих примерах мы использовали каналы для ограничения количества активных горутин.
//Это позволяет контролировать параллельное выполнение задач и предотвращать избыточное создание горутин,
//что может привести к проблемам с производительностью и использованием ресурсов.

//func worker(id int, jobs <-chan int, results chan<- int) {
//	for job := range jobs {
//		// Выполнение работы
//		result := job * 2
//		results <- result
//	}
//}
//
//func main() {
//
//	numWorkers := 3
//
//	jobs := make(chan int, 10)
//	results := make(chan int, 10)
//
//	// Создание горутин-работников
//	for i := 1; i <= numWorkers; i++ {
//		go worker(i, jobs, results)
//	}
//
//	// Отправка задач в канал
//	for i := 1; i <= 10; i++ {
//		jobs <- i
//	}
//	close(jobs)
//
//	// Получение результатов из канала
//	for i := 1; i <= 10; i++ {
//		result := <-results
//		fmt.Println("Результат работы:", result)
//	}
//	close(results)
//}
